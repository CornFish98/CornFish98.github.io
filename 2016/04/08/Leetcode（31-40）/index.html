<!DOCTYPE html>
<!--[if lte IE 8 ]>
<html class="ie" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<![endif]-->
<!--[if (gte IE 9)|!(IE)]><!-->
<!--
***************  *      *     *
      8          *    *       *
      8          *  *         *
      8          **           *
      8          *  *         *
      8          *    *       *
      8          *      *     *
      8          *        *   ***********    -----Theme By Kieran(http://go.kieran.top)
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<!--<![endif]-->

<head>
  <title>Leetcode（31-40） | CornFish</title>
  <!-- Meta data -->
    <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" >
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="generator" content="CornFish">
    <meta name="author" content="ZKY">
    <meta name="description" content="" />
    <meta name="keywords" content="" />

    <!-- Favicon, (keep icon in root folder) -->
    <link rel="Shortcut Icon" href="/img/favicon.ico" type="image/ico">

    <link rel="alternate" href="/atom.xml" title="CornFish" type="application/atom+xml">
    <link rel="stylesheet" href="/css/all.css" media="screen" type="text/css">
	
    <link rel="stylesheet" href="/highlightjs/vs.css" type="text/css">
    
    

    <!-- Custom stylesheet, (add custom styles here, always load last) -->
    <!-- Load our stylesheet for IE8 -->
    <!--[if IE 8]>
    <link rel="stylesheet" type="text/css" href="/css/ie8.css" />
    <![endif]-->

    <!-- Google Webfonts (Monserrat 400/700, Open Sans 400/600) -->
    <link href='//fonts.useso.com/css?family=Montserrat:400,700' rel='stylesheet' type='text/css'>
    <link href='//fonts.useso.com/css?family=Open+Sans:400,600' rel='stylesheet' type='text/css'>

    <!-- Load our fonts individually if IE8+, to avoid faux bold & italic rendering -->
    <!--[if IE]>
    <link href='http://fonts.useso.com/css?family=Montserrat:400' rel='stylesheet' type='text/css'>
    <link href='http://fonts.useso.com/css?family=Montserrat:700' rel='stylesheet' type='text/css'>
    <link href='http://fonts.useso.com/css?family=Open+Sans:400' rel='stylesheet' type='text/css'>
    <link href='http://fonts.useso.com/css?family=Open+Sans:600' rel='stylesheet' type='text/css'>
    <![endif]-->

    <!-- jQuery | Load our jQuery, with an alternative source fallback to a local version if request is unavailable -->
    <script src="/js/jquery-1.11.1.min.js"></script>
    <script>window.jQuery || document.write('<script src="js/jquery-1.11.1.min.js"><\/script>')</script>

    <!-- Load these in the <head> for quicker IE8+ load times -->
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
    <script src="/js/html5shiv.min.js"></script>
    <script src="/js/respond.min.js"></script>
    <![endif]-->










  
  
  

  
  <style>.col-md-8.col-md-offset-2.opening-statement img{display:none;}</style>
</head>

<!--
<body class="post-template">
-->
<body id="index" class="lightnav animsition">

      <!-- ============================ Off-canvas navigation =========================== -->

    <div class="sb-slidebar sb-right sb-style-overlay sb-momentum-scrolling">
        <div class="sb-close" aria-label="Close Menu" aria-hidden="true">
            <img src="/img/close.png" alt="Close"/>
        </div>
        <!-- Lists in Slidebars -->
        <ul class="sb-menu">
            <li><a href="/" class="animsition-link" title="Home">Home</a></li>
            <li><a href="/archives" class="animsition-link" title="archive">archives</a></li>
            <!-- Dropdown Menu -->
			 
            <li>
                <a class="sb-toggle-submenu">Works<span class="sb-caret"></span></a>
                <ul class="sb-submenu">
                    
                        <li><a href="http://cornfish98.com" target="_BLANK" class="animsition-link">MyBlog</a></li>
                    
                </ul>
            </li>
            
            
        	<li>
        		<a class="sb-toggle-submenu">Categories<span class="sb-caret"></span></a>
            	<ul class="sb-submenu">
				  	
				    <li><a href="/categories/C/" class="animsition-link">C++<small>(1)</small></a></li>
				    
				    <li><a href="/categories/Computer-Networking/" class="animsition-link">Computer Networking<small>(1)</small></a></li>
				    
				    <li><a href="/categories/Data-Structure-and-Algorithms/" class="animsition-link">Data Structure and Algorithms<small>(1)</small></a></li>
				    
				    <li><a href="/categories/Information-Security/" class="animsition-link">Information Security<small>(1)</small></a></li>
				    
				    <li><a href="/categories/LeetCode/" class="animsition-link">LeetCode<small>(4)</small></a></li>
				    
				</ul>
        	</li>
			
            
            <li>
                <a class="sb-toggle-submenu">Links<span class="sb-caret"></span></a>
                <ul class="sb-submenu">
                    
                    <li><a href="http://www.cornfish98.com/" class="animsition-link">ZKY</a></li>
                    
                </ul>
            </li>
            
        </ul>
        <!-- Lists in Slidebars -->
        <ul class="sb-menu secondary">
            <li><a href="/about.html" class="animsition-link" title="about">About</a></li>
            <li><a href="/atom.xml" class="animsition-link" title="rss">RSS</a></li>
        </ul>
    </div>
    
    <!-- ============================ END Off-canvas navigation =========================== -->

    <!-- ============================ #sb-site Main Page Wrapper =========================== -->

    <div id="sb-site">
        <!-- #sb-site - All page content should be contained within this id, except the off-canvas navigation itself -->

        <!-- ============================ Header & Logo bar =========================== -->

        <div id="navigation" class="navbar navbar-fixed-top">
            <div class="navbar-inner">
                <div class="container">
                    <!-- Nav logo -->
                    <div class="logo">
                        <a href="/" title="Logo" class="animsition-link">
                        
                        </a>
                    </div>
                    <!-- // Nav logo -->
                    <!-- Info-bar -->
                    <nav>
                        <ul class="nav">
                            <li><a href="/" class="animsition-link">CornFish</a></li>
                            <li class="nolink">一年一年，一天一念</li>
                            
                            <li><a href="https://github.com/" title="Github" target="_blank"><i class="icon-github"></i></a></li>
                            
                            
                            
                            
                            <li><a href="https://google.com/" title="Google-Plus" target="_blank"><i class="icon-google-plus"></i></a></li>
                            
                            
                            <li><a href="http://weibo.com/" title="Sina-Weibo" target="_blank"><i class="icon-sina-weibo"></i></a></li>
                            
                            <li class="nolink"><span></span></li>
                        </ul>
                    </nav>
                    <!--// Info-bar -->
                </div>
                <!-- // .container -->
                <div class="learnmore sb-toggle-right">More</div>
                <button type="button" class="navbar-toggle menu-icon sb-toggle-right" title="More">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar before"></span>
                <span class="icon-bar main"></span>
                <span class="icon-bar after"></span>
                </button>
            </div>
            <!-- // .navbar-inner -->
        </div>

        <!-- ============================ Header & Logo bar =========================== -->

        <!-- ============================ Hero Image =========================== -->

        <section id="hero" class="scrollme">
            <div class="container-fluid element-img" style="background: url(/img/bg_img.jpg) no-repeat center center fixed;background-size: cover">
                <div class="row">
                    <div class="col-xs-12 col-sm-8 col-sm-offset-2 col-md-8 col-md-offset-2 vertical-align cover boost text-center">
                        <div class="center-me animateme" data-when="exit" data-from="0" data-to="0.6" data-opacity="0" data-translatey="100">
                            <div>
                            	
                                <h2>Welcome to Cornfish's blog!</h2>
                                <p></p>
				    			
                                <h2></h2>
                                <p>每一个不曾起舞的日子都是对生命的辜负。</p>
				    			

                            </div>
                        </div>
                    </div>
                    <!-- // .col-md-12 -->
                </div>
                <div class="herofade beige-dk"></div>
            </div>
        </section>

        <!-- Height spacing helper -->
        <div class="heightblock"></div>
        <!-- // End height spacing helper -->

        <!-- ============================ END Hero Image =========================== -->
      
<section id="intro">
    <div class="container">
        <div class="row col-md-offset-2">
            <div class="col-md-8">
    			<span class="post-meta">
      <time datetime="2016-04-08T15:55:15.000Z" itemprop="datePublished">
          2016-04-08
      </time>
    
</span>
                <h1>Leetcode（31-40）</h1>
            </div>
        </div>
        <div class="col-md-8 col-md-offset-2">
      		<h2 id="LeetCode-31-Next-Permutation"><a href="#LeetCode-31-Next-Permutation" class="headerlink" title="LeetCode-31 Next Permutation"></a>LeetCode-31 Next Permutation</h2><h5 id="Array"><a href="#Array" class="headerlink" title="Array "></a><font color="red">Array </font></h5><p>Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.</p>
<p>If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).</p>
<p>The replacement must be in-place, do not allocate extra memory.</p>
<p><strong>Here are some examples.</strong> Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.</p>
<blockquote>
<p>1,2,3 → 1,3,2<br>3,2,1 → 1,2,3<br>1,1,5 → 1,5,1</p>
</blockquote>
<p>题目意思是求出给定排列的下一个排列，如果给定排列没有下一个排列（已经是最大排列），则输出其最小排列（所有元素按非递减序列排序）</p>
<h4 id="my-Solution"><a href="#my-Solution" class="headerlink" title="my Solution :"></a><strong>my Solution :</strong></h4><p>函数实现原理如下：</p>
<p>在当前序列中，从尾端往前寻找两个相邻元素，前一个记为a，后一个记为b，并且满足a&lt;b。然后再从尾端开始寻找另一个元素c，使其满足a&lt; c，将第a与c对调，并将b之后（包括b）的所有元素颠倒排序，即求出下一个排列。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (nums.size() &lt;= <span class="number">1</span>)</span><br><span class="line">			return;</span><br><span class="line">		<span class="keyword">int</span> i = nums.size() - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> j;</span><br><span class="line">		<span class="keyword">for</span> (j = nums.size() - <span class="number">2</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">			<span class="keyword">if</span> (nums[j] &lt; nums[j + <span class="number">1</span>])</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">while</span> (nums[i] &lt;= nums[j])</span><br><span class="line">				i--;</span><br><span class="line">			swap(nums[i], nums[j]);</span><br><span class="line">		&#125;</span><br><span class="line">		reverse(nums.begin() + j + <span class="number">1</span>, nums.end());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="LeetCode-32-Longest-Valid-Parentheses"><a href="#LeetCode-32-Longest-Valid-Parentheses" class="headerlink" title="LeetCode-32 Longest Valid Parentheses"></a>LeetCode-32 Longest Valid Parentheses</h2><h5 id="Dynamic-Programming-String"><a href="#Dynamic-Programming-String" class="headerlink" title="Dynamic Programming String "></a><font color="red">Dynamic Programming String </font></h5><p>Given a string containing just the characters ‘(‘ and ‘)’, find the length of the longest valid (well-formed) parentheses substring.</p>
<p>For “(()”, the longest valid parentheses substring is “()”, which has length = 2.</p>
<p>Another example is “)()())”, where the longest valid parentheses substring is “()()”, which has length = 4.</p>
<h4 id="my-Solution-1"><a href="#my-Solution-1" class="headerlink" title="my Solution :"></a><strong>my Solution :</strong></h4><p>This solution uses DP. The main idea is as follows: I construct a array longest[], for any longest[i], it stores the longest length of valid parentheses which is end at i. </p>
<p><strong>And the DP idea is :</strong> </p>
<p>If s[i] is ‘(‘,</p>
<blockquote>
<p>set longest[i] to 0,because any string end with ‘(‘ cannot be a valid one. </p>
</blockquote>
<p>Else if s[i] is ‘)’ </p>
<pre><code>&gt; If s[i-1] is &apos;(&apos;, longest[i] = longest[i-2] + 2 
&gt;Else if s[i-1] is &apos;)&apos; and s[i-longest[i-1]-1] == &apos;(&apos;, longest[i] = longest[i-1] + 2 + longest[i-longest[i-1]-2] 
</code></pre><p><strong>For example,</strong> input “()(())”, at i = 5, longest array is [0,2,0,0,2,0], longest[5] = longest[4] + 2 + longest[1] = 6. </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> len = s.length();</span><br><span class="line">		<span class="keyword">if</span> (len &lt;= <span class="number">1</span>)</span><br><span class="line">			return <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> max_len = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">//记录以S[i]结尾的子串的longestValidParentheses长度值</span></span><br><span class="line">		<span class="comment">//即这个ValidParentheses必须是以s[i]结尾的</span></span><br><span class="line">		<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; longest_val;</span><br><span class="line">		longest_val.push_back(<span class="number">0</span>);<span class="comment">//以s[0]结尾的子串的longestValidParentheses长度值为0</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.size(); i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (s[i] == <span class="string">'('</span>)</span><br><span class="line">				longest_val.push_back(<span class="number">0</span>);</span><br><span class="line">			<span class="keyword">else</span> &#123;<span class="comment">//s[i] == ')'</span></span><br><span class="line">				<span class="keyword">if</span> (s[i - <span class="number">1</span>] == <span class="string">'('</span>) &#123;</span><br><span class="line">					<span class="keyword">if</span> (i - <span class="number">2</span> &gt;= <span class="number">0</span>)</span><br><span class="line">						longest_val.push_back(longest_val[i - <span class="number">2</span>] + <span class="number">2</span>);</span><br><span class="line">					<span class="keyword">else</span></span><br><span class="line">						longest_val.push_back(<span class="number">2</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;<span class="comment">//s[i - 1] == ')'</span></span><br><span class="line">					<span class="keyword">if</span> (i - longest_val[i - <span class="number">1</span>] - <span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">						<span class="keyword">if</span> (s[i - longest_val[i - <span class="number">1</span>] - <span class="number">1</span>] == <span class="string">'('</span>) &#123;</span><br><span class="line">							<span class="keyword">if</span> (i - longest_val[i - <span class="number">1</span>] - <span class="number">2</span> &gt;= <span class="number">0</span>)</span><br><span class="line">								longest_val.push_back(longest_val[i - longest_val[i - <span class="number">1</span>] - <span class="number">2</span>] + longest_val[i - <span class="number">1</span>] + <span class="number">2</span>);</span><br><span class="line">							<span class="keyword">else</span><span class="comment">//i - longest_val[i - 1] - 2 &lt; 0</span></span><br><span class="line">								longest_val.push_back(longest_val[i - <span class="number">1</span>] + <span class="number">2</span>);</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">else</span> &#123;<span class="comment">//s[i - longest_val[i - 1] - 1] == ')'</span></span><br><span class="line">							longest_val.push_back(<span class="number">0</span>);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> &#123;<span class="comment">//i - longest_val[i - 1] - 1 &lt; 0</span></span><br><span class="line">						longest_val.push_back(<span class="number">0</span>);</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			max_len = longest_val[i] &gt; max_len ? longest_val[i] : max_len;</span><br><span class="line">		&#125;</span><br><span class="line">		return max_len;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以上代码包含有重复情况，可以进一步优化：</p>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化:"></a><strong>优化:</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.length() &lt;= <span class="number">1</span>) return <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> curMax = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; longest(s.size(),<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i] == <span class="string">')'</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(s[i<span class="number">-1</span>] == <span class="string">'('</span>)&#123;</span><br><span class="line">                        longest[i] = (i<span class="number">-2</span>) &gt;= <span class="number">0</span> ? (longest[i<span class="number">-2</span>] + <span class="number">2</span>) : <span class="number">2</span>;</span><br><span class="line">                        curMax = max(longest[i],curMax);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123; <span class="comment">// if s[i-1] == ')', combine the previous length.</span></span><br><span class="line">                        <span class="keyword">if</span>(i-longest[i<span class="number">-1</span>]<span class="number">-1</span> &gt;= <span class="number">0</span> &amp;&amp; s[i-longest[i<span class="number">-1</span>]<span class="number">-1</span>] == <span class="string">'('</span>)&#123;</span><br><span class="line">                            longest[i] = longest[i<span class="number">-1</span>] + <span class="number">2</span> + ((i-longest[i<span class="number">-1</span>]<span class="number">-2</span> &gt;= <span class="number">0</span>)?longest[i-longest[i<span class="number">-1</span>]<span class="number">-2</span>]:<span class="number">0</span>);</span><br><span class="line">                            curMax = max(longest[i],curMax);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//else if s[i] == '(', skip it, because longest[i] must be 0</span></span><br><span class="line">            &#125;</span><br><span class="line">            return curMax;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h4 id="进一步优化"><a href="#进一步优化" class="headerlink" title="进一步优化:"></a><strong>进一步优化:</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">longestValidParentheses(<span class="built_in">string</span> s) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() &lt;= <span class="number">1</span>) return <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> curMax = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; longest(s.size(),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">')'</span> &amp;&amp; i-longest[i<span class="number">-1</span>]<span class="number">-1</span> &gt;= <span class="number">0</span> &amp;&amp; s[i-longest[i<span class="number">-1</span>]<span class="number">-1</span>] == <span class="string">'('</span>)&#123;</span><br><span class="line">                    longest[i] = longest[i<span class="number">-1</span>] + <span class="number">2</span> + ((i-longest[i<span class="number">-1</span>]<span class="number">-2</span> &gt;= <span class="number">0</span>)?longest[i-longest[i<span class="number">-1</span>]<span class="number">-2</span>]:<span class="number">0</span>);</span><br><span class="line">                    curMax = max(longest[i],curMax);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return curMax;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2:"></a><strong>Solution 2:</strong></h4><p><strong>very nice solution!</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">        stk.push(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> maxL=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> t=stk.top();</span><br><span class="line">            <span class="keyword">if</span>(t!=<span class="number">-1</span>&amp;&amp;s[i]==<span class="string">')'</span>&amp;&amp;s[t]==<span class="string">'('</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                stk.pop();</span><br><span class="line">                maxL=max(maxL,i-stk.top());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                stk.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return maxL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="LeetCode-33-Search-in-Rotated-Sorted-Array"><a href="#LeetCode-33-Search-in-Rotated-Sorted-Array" class="headerlink" title="LeetCode-33 Search in Rotated Sorted Array"></a>LeetCode-33 Search in Rotated Sorted Array</h2><h5 id="Array-Binary-Search"><a href="#Array-Binary-Search" class="headerlink" title="Array Binary Search "></a><font color="red">Array Binary Search </font></h5><p>Suppose a sorted array is rotated at some pivot unknown to you beforehand.</p>
<blockquote>
<p>(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).</p>
</blockquote>
<p>You are given a target value to search. If found in the array return its index, otherwise return -1.</p>
<p>You may assume no duplicate exists in the array.</p>
<h4 id="my-Solution-2"><a href="#my-Solution-2" class="headerlink" title="my Solution :"></a><strong>my Solution :</strong></h4><p>写二分法时，在条件的&gt;=,&lt;=和mid+1，mid-1的问题上要格外小心。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">		return rotateSearch(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>, target);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">rotateSearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (a == b)</span><br><span class="line">			return nums[a] == target ? a : <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">int</span> mid = (a + b) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (nums[a] &gt; nums[mid] &amp;&amp; nums[b] &gt; nums[mid]) &#123;</span><br><span class="line">			<span class="keyword">if</span> (target &gt; nums[mid] &amp;&amp; target &lt;= nums[b])<span class="comment">//=要和mid+1一起出现</span></span><br><span class="line">				return binarySearch(nums, mid + <span class="number">1</span>, b, target);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				return rotateSearch(nums, a, mid, target);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (nums[a] &lt; nums[mid] &amp;&amp; nums[b] &lt; nums[mid]) &#123;</span><br><span class="line">			<span class="keyword">if</span> (target &gt;= nums[a] &amp;&amp; target &lt; nums[mid])</span><br><span class="line">				return binarySearch(nums, a, mid - <span class="number">1</span>, target);<span class="comment">//=要和mid-1一起出现</span></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				return rotateSearch(nums, mid, b, target);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			return binarySearch(nums, a, b, target);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (a == b)</span><br><span class="line">			return nums[a] == target ? a : <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">abs</span>(a - b) == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (nums[a] == target)</span><br><span class="line">				return a;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (nums[b] == target)</span><br><span class="line">				return b;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				return <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (target &gt; nums[b] || target &lt; nums[a])</span><br><span class="line">			return <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">int</span> mid = (a + b) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (target &gt; nums[mid])</span><br><span class="line">			return binarySearch(nums, mid + <span class="number">1</span>, b, target);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			return binarySearch(nums, a, mid, target);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="my-Solution-2"><a href="#my-Solution-2" class="headerlink" title="my Solution 2:"></a><strong>my Solution 2:</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l+r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (target == nums[mid])</span><br><span class="line">                return mid;</span><br><span class="line">            <span class="comment">// there exists rotation; the middle element is in the left part of the array</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[r]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (target &lt; nums[mid] &amp;&amp; target &gt;= nums[l])</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// there exists rotation; the middle element is in the right part of the array</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; nums[l]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (target &gt; nums[mid] &amp;&amp; target &lt;= nums[r])</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// there is no rotation; just like normal binary search</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (target &lt; nums[mid])</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="LeetCode-34-Search-for-a-Range"><a href="#LeetCode-34-Search-for-a-Range" class="headerlink" title="LeetCode-34 Search for a Range"></a>LeetCode-34 Search for a Range</h2><h5 id="Array-Binary-Search-1"><a href="#Array-Binary-Search-1" class="headerlink" title="Array Binary Search "></a><font color="red">Array Binary Search </font></h5><p>Given a sorted array of integers, find the starting and ending position of a given target value.</p>
<p>Your algorithm’s runtime complexity must be in the order of O(log n).</p>
<p>If the target is not found in the array, return [-1, -1].</p>
<p><strong>For example,</strong></p>
<blockquote>
<p>Given [5, 7, 7, 8, 8, 10] and target value 8,<br>return [3, 4].</p>
</blockquote>
<h4 id="my-Solution-3"><a href="#my-Solution-3" class="headerlink" title="my Solution :"></a><strong>my Solution :</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; searchRange(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> j = nums.size() - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> mid;</span><br><span class="line">		<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret(<span class="number">2</span>, <span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">			mid = (i + j) / <span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span> (target &gt; nums[mid])</span><br><span class="line">				i = mid + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				j = mid;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (nums[i] != target)</span><br><span class="line">			return ret;</span><br><span class="line">		ret[<span class="number">0</span>] = i;</span><br><span class="line"></span><br><span class="line">		i = <span class="number">0</span>; j = nums.size() - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">			mid = (i + j) / <span class="number">2</span> + <span class="number">1</span>;<span class="comment">//必须+1，否则会死循环</span></span><br><span class="line">			<span class="keyword">if</span> (target &lt; nums[mid])</span><br><span class="line">				j = mid - <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				i = mid;</span><br><span class="line">		&#125;</span><br><span class="line">		ret[<span class="number">1</span>] = j;</span><br><span class="line">		return ret;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>The problem can be simply broken down as two binary searches for the begining and end of the range, respectively:</strong></p>
<p>First let’s find the left boundary of the range. We initialize the range to [i=0, j=n-1]. In each step, calculate the middle element [mid = (i+j)/2]. Now according to the relative value of A[mid] to target, there are three possibilities:</p>
<blockquote>
<p>1.If A[mid] &lt; target, then the range must begins on the right of mid (hence i = mid+1 for the next iteration)<br>2.If A[mid] &gt; target, it means the range must begins on the left of mid (j = mid-1)<br>3.If A[mid] = target, then the range must begins on the left of or at mid (j= mid)</p>
</blockquote>
<p>Since we would move the search range to the same side for case 2 and 3, we might as well merge them as one single case so that less code is needed:</p>
<blockquote>
<p>2*. If A[mid] &gt;= target, j = mid;</p>
</blockquote>
<p>Surprisingly, 1 and 2* are the only logic you need to put in loop while (i &lt; j). When the while loop terminates, the value of i/j is where the start of the range is. Why?</p>
<p>No matter what the sequence originally is, as we narrow down the search range, eventually we will be at a situation where there are only two elements in the search range. Suppose our target is 5, then we have only 7 possible cases:</p>
<blockquote>
<p>case 1: [5 7] (A[i] = target &lt; A[j])<br>case 2: [5 3] (A[i] = target &gt; A[j])<br>case 3: [5 5] (A[i] = target = A[j])<br>case 4: [3 5] (A[j] = target &gt; A[i])<br>case 5: [3 7] (A[i] &lt; target &lt; A[j])<br>case 6: [3 4] (A[i] &lt; A[j] &lt; target)<br>case 7: [6 7] (target &lt; A[i] &lt; A[j])</p>
</blockquote>
<p>For case 1, 2 and 3, if we follow the above rule, since mid = i =&gt; A[mid] = target in these cases, then we would set j = mid. Now the loop terminates and i and j both point to the first 5.</p>
<p>For case 4, since A[mid] &lt; target, then set i = mid+1. The loop terminates and both i and j point to 5.</p>
<p>For all other cases, by the time the loop terminates, A[i] is not equal to 5. So we can easily know 5 is not in the sequence if the comparison fails.</p>
<p>In conclusion, when the loop terminates, if A[i]==target, then i is the left boundary of the range; otherwise, just return -1;</p>
<p>For the right of the range, we can use a similar idea. Again we can come up with several rules:</p>
<blockquote>
<p>1.If A[mid] &gt; target, then the range must begins on the left of mid (j = mid-1)<br>2.If A[mid] &lt; target, then the range must begins on the right of mid (hence i = mid+1 for the next iteration)<br>3.If A[mid] = target, then the range must begins on the right of or at mid (i= mid)</p>
</blockquote>
<p>Again, we can merge condition 2 and 3 into:</p>
<blockquote>
<p>2* If A[mid] &lt;= target, then i = mid;</p>
</blockquote>
<p>However, the terminate condition on longer works this time. Consider the following case:</p>
<p>[5 7], target = 5<br>Now A[mid] = 5, then according to rule 2, we set i = mid. This practically does nothing because i is already equal to mid. As a result, the search range is not moved at all!</p>
<p>The solution is by using a small trick: instead of calculating mid as mid = (i+j)/2, we now do:</p>
<p>mid = (i+j)/2+1<br>Why does this trick work? When we use mid = (i+j)/2, the mid is rounded to the lowest integer. In other words, mid is always biased towards the left. This means we could have i == mid when j - i == mid, but we NEVER have j == mid. So in order to keep the search range moving, you must make sure the new i is set to something different than mid, otherwise we are at the risk that i gets stuck. But for the new j, it is okay if we set it to mid, since it was not equal to mid anyways. Our two rules in search of the left boundary happen to satisfy these requirements, so it works perfectly in that situation. Similarly, when we search for the right boundary, we must make sure i won’t get stuck when we set the new i to i = mid. The easiest way to achieve this is by making mid biased to the right, i.e. mid = (i+j)/2+1.</p>
<p>All this reasoning boils down to the following simple code:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; searchRange(<span class="keyword">int</span> A[], <span class="keyword">int</span> n, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = n - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret(<span class="number">2</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="comment">// Search for the left one</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (i + j) /<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (A[mid] &lt; target) i = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> j = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (A[i]!=target) return ret;</span><br><span class="line">    <span class="keyword">else</span> ret[<span class="number">0</span>] = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Search for the right one</span></span><br><span class="line">    j = n<span class="number">-1</span>;  <span class="comment">// We don't have to set i to 0 the second time.</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (i + j) /<span class="number">2</span> + <span class="number">1</span>;   <span class="comment">// Make mid biased to the right</span></span><br><span class="line">        <span class="keyword">if</span> (A[mid] &gt; target) j = mid - <span class="number">1</span>;  </span><br><span class="line">        <span class="keyword">else</span> i = mid;               <span class="comment">// So that this won't make the search range stuck.</span></span><br><span class="line">    &#125;</span><br><span class="line">    ret[<span class="number">1</span>] = j;</span><br><span class="line">    return ret; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="LeetCode-35-Search-Insert-Position"><a href="#LeetCode-35-Search-Insert-Position" class="headerlink" title="LeetCode-35 Search Insert Position"></a>LeetCode-35 Search Insert Position</h2><h5 id="Array-Binary-Search-2"><a href="#Array-Binary-Search-2" class="headerlink" title="Array Binary Search "></a><font color="red">Array Binary Search </font></h5><p>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p>
<p>You may assume no duplicates in the array.</p>
<p><strong>Here are few examples.</strong></p>
<blockquote>
<p>[1,3,5,6], 5 → 2<br>[1,3,5,6], 2 → 1<br>[1,3,5,6], 7 → 4<br>[1,3,5,6], 0 → 0</p>
</blockquote>
<h4 id="my-Solution-4"><a href="#my-Solution-4" class="headerlink" title="my Solution :"></a><strong>my Solution :</strong></h4><p>参考33，34题，二分法中：target &gt; nums[mid]与target &lt; nums[mid]的条件的不同直接影响返回结果的位置（向左or向右)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> j = nums.size() - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> mid;</span><br><span class="line">		<span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">			mid = (i + j) / <span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span> (target &gt; nums[mid])</span><br><span class="line">				i = mid + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				j = mid;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (target == nums[i] || target &lt; nums[i])</span><br><span class="line">			return i;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			return i + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="LeetCode-36-Valid-Sudoku"><a href="#LeetCode-36-Valid-Sudoku" class="headerlink" title="LeetCode-36 Valid Sudoku"></a>LeetCode-36 Valid Sudoku</h2><h5 id="Hash-Table"><a href="#Hash-Table" class="headerlink" title="Hash Table "></a><font color="red">Hash Table </font></h5><p>Determine if a Sudoku is valid, according to: Sudoku Puzzles - The Rules.</p>
<p>The Sudoku board could be partially filled, where empty cells are filled with the character ‘.’.</p>
<p><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-04-09-250px-Sudoku-by-L2G-20050714.svg.png" alt="250px-Sudoku-by-L2G-20050714.svg"></p>
<p>A partially filled sudoku which is valid.</p>
<p><strong>Note:</strong><br>A valid Sudoku board (partially filled) is not necessarily solvable. Only the filled cells need to be validated.</p>
<p>####<strong>my Solution :</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">isValidSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &gt;&amp; board)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> row_used[<span class="number">10</span>][<span class="number">10</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">		<span class="keyword">int</span> column_used[<span class="number">10</span>][<span class="number">10</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">		<span class="keyword">int</span> subbox_used[<span class="number">10</span>][<span class="number">10</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.size(); i++) </span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board.size(); j++) </span><br><span class="line">				<span class="keyword">if</span> (board[i][j] != <span class="string">'.'</span>) &#123;</span><br><span class="line">					<span class="keyword">int</span> curr_num = board[i][j] - <span class="string">'0'</span>;</span><br><span class="line">					<span class="keyword">int</span> k = (i / <span class="number">3</span>) * <span class="number">3</span> + (j / <span class="number">3</span>) + <span class="number">1</span>;<span class="comment">//计算对应的subbox序号</span></span><br><span class="line">					<span class="keyword">if</span> (row_used[i + <span class="number">1</span>][curr_num] || column_used[j + <span class="number">1</span>][curr_num] || subbox_used[k][curr_num])</span><br><span class="line">						return <span class="literal">false</span>;</span><br><span class="line">					row_used[i + <span class="number">1</span>][curr_num] = <span class="number">1</span>;<span class="comment">//第i+1行出现过字符board[i][j]</span></span><br><span class="line">					column_used[j + <span class="number">1</span>][curr_num] = <span class="number">1</span>;<span class="comment">//第j+1行出现过字符board[i][j]</span></span><br><span class="line">					subbox_used[k][curr_num] = <span class="number">1</span>;<span class="comment">//第k个subbox出现过字符board[i][j]</span></span><br><span class="line">				&#125;</span><br><span class="line">		return <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="LeetCode-37-Sudoku-Solver"><a href="#LeetCode-37-Sudoku-Solver" class="headerlink" title="LeetCode-37 Sudoku Solver"></a>LeetCode-37 Sudoku Solver</h2><h5 id="Backtracking-Hash-Table"><a href="#Backtracking-Hash-Table" class="headerlink" title="Backtracking Hash Table "></a><font color="red">Backtracking Hash Table </font></h5><p>Write a program to solve a Sudoku puzzle by filling the empty cells.</p>
<p>Empty cells are indicated by the character ‘.’.</p>
<p>You may assume that there will be only one unique solution.</p>
<p><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-04-09-250px-Sudoku-by-L2G-20050714.svg.png" alt="250px-Sudoku-by-L2G-20050714.svg"></p>
<p>A sudoku puzzle…<br><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-04-09-250px-Sudoku-by-L2G-20050714_solution.svg.png" alt="250px-Sudoku-by-L2G-20050714_solution.svg"></p>
<p>…and its solution numbers marked in red.</p>
<h4 id="my-Solution-5"><a href="#my-Solution-5" class="headerlink" title="my Solution :"></a><strong>my Solution :</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; positions;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++)</span><br><span class="line">				<span class="keyword">if</span> (board[i][j] == <span class="string">'.'</span>) &#123;</span><br><span class="line">					positions.push_back(&#123; i,j &#125;);</span><br><span class="line">				&#125;	</span><br><span class="line">		hasSolve(board, positions, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">hasSolve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; pos, <span class="keyword">int</span> curr)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (curr &gt;= pos.size())</span><br><span class="line">			return <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">int</span> x = pos[curr].first;</span><br><span class="line">		<span class="keyword">int</span> y = pos[curr].second;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;<span class="comment">//下标i遍历字符‘1’-‘9’,看那个字符可以作为解</span></span><br><span class="line">			<span class="keyword">int</span> ok = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">char</span> curr_char = <span class="string">'1'</span> + i;</span><br><span class="line">			<span class="comment">//check row and column</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123;<span class="comment">//下标j遍历第x行和第y列的所有元素，看是否和curr_char冲突</span></span><br><span class="line">				<span class="keyword">if</span> (board[x][j] == curr_char || board[j][y] == curr_char) &#123;</span><br><span class="line">					ok = <span class="number">0</span>;</span><br><span class="line">					<span class="keyword">break</span>;<span class="comment">//证明字符curr_char = '1' + i不可行，尝试'1' + （i + 1）</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (ok) &#123;<span class="comment">//check sub-box</span></span><br><span class="line">				<span class="keyword">int</span> pos_x = x / <span class="number">3</span> * <span class="number">3</span>;<span class="comment">//(pos_x,pos_y)是(x,y)所在sub-box的第一个格子的坐标</span></span><br><span class="line">				<span class="keyword">int</span> pos_y = y / <span class="number">3</span> * <span class="number">3</span>;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> px = pos_x; px &lt; pos_x + <span class="number">3</span>; px++) &#123;</span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">int</span> py = pos_y; py &lt; pos_y + <span class="number">3</span>; py++)</span><br><span class="line">						<span class="keyword">if</span> (curr_char == board[px][py]) &#123;</span><br><span class="line">							ok = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">						&#125;</span><br><span class="line">					<span class="keyword">if</span> (!ok) <span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (ok) &#123;<span class="comment">//如果ok==1,则说明curr_char和它所在row,column,sub-box都不冲突</span></span><br><span class="line">				board[x][y] = curr_char;</span><br><span class="line">				<span class="keyword">if</span> (hasSolve(board, pos, curr + <span class="number">1</span>))</span><br><span class="line">					return <span class="literal">true</span>;</span><br><span class="line">				<span class="keyword">else</span> board[x][y] = <span class="string">'.'</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>output:</strong></p>
<p><img src="http://7xrobr.com1.z0.glb.clouddn.com/2016-04-09-sudoku.png" alt="sudoku"></p>
<h4 id="Sharing-my-2ms-C-solution-with-comments-and-explanations"><a href="#Sharing-my-2ms-C-solution-with-comments-and-explanations" class="headerlink" title="Sharing my 2ms C++ solution with comments and explanations."></a>Sharing my 2ms C++ solution with comments and explanations.</h4><p>This is one of the fastest Sudoku solvers I’ve ever written. It is compact enough - just 150 lines of C++ code with comments. I thought it’d be interesting to share it, since it combines several techniques like reactive network update propagation and backtracking with very aggressive pruning.</p>
<p>The algorithm is online - it starts with an empty board and as you add numbers to it, it starts solving the Sudoku.</p>
<p>Unlike in other solutions where you have bitmasks of allowed/disallowed values per row/column/square, this solution track bitmask for every(!) cell, forming a set of constraints for the allowed values for each particular cell. Once a value is written into a cell, new constraints are immediately propagated to row, column and 3x3 square of the cell. If during this process a value of other cell can be unambiguously deduced - then the value is set, new constraints are propagated, so on…. You can think about this as an implicit reactive network of cells.</p>
<p>If we’re lucky (and we’ll be lucky for 19 of 20 of Sudokus published in magazines) then Sudoku is solved at the end (or even before!) processing of the input.</p>
<p>Otherwise, there will be empty cells which have to be resolved. Algorithm uses backtracking for this purpose. To optimize it, algorithm starts with the cell with the smallest ambiguity. This could be improved even further by using priority queue (but it’s not implemented here). Backtracking is more or less standard, however, at each step we guess the number, the reactive update propagation comes back into play and it either quickly proves that the guess is unfeasible or significantly prunes the remaining search space.</p>
<p>It’s interesting to note, that in this case taking and restoring snapshots of the compact representation of the state is faster than doing backtracking rollback by “undoing the moves”.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="keyword">struct</span> cell <span class="comment">// encapsulates a single cell on a Sudoku board</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">uint8_t</span> value; <span class="comment">// cell value 1..9 or 0 if unset</span></span><br><span class="line">        <span class="comment">// number of possible (unconstrained) values for the cell</span></span><br><span class="line">        <span class="keyword">uint8_t</span> numPossibilities;</span><br><span class="line">        <span class="comment">// if bitset[v] is 1 then value can't be v</span></span><br><span class="line">        <span class="built_in">bitset</span>&lt;10&gt; constraints;</span><br><span class="line">        cell() : value(<span class="number">0</span>), numPossibilities(<span class="number">9</span>),constraints() &#123;&#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">array</span>&lt;<span class="built_in">array</span>&lt;cell,9&gt;,9&gt; cells;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sets the value of the cell to [v]</span></span><br><span class="line">    <span class="comment">// the function also propagates constraints to other cells and deduce new values where possible</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> v)</span></span><br><span class="line">    </span>&#123; </span><br><span class="line">        <span class="comment">// updating state of the cell</span></span><br><span class="line">        cell&amp; c = cells[i][j];</span><br><span class="line">        <span class="keyword">if</span> (c.value == v)</span><br><span class="line">            return <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (c.constraints[v])</span><br><span class="line">            return <span class="literal">false</span>;</span><br><span class="line">        c.constraints = <span class="built_in">bitset</span>&lt;<span class="number">10</span>&gt;(<span class="number">0x3FE</span>); <span class="comment">// all 1s</span></span><br><span class="line">        c.constraints.reset(v);</span><br><span class="line">        c.numPossibilities = <span class="number">1</span>;</span><br><span class="line">        c.value = v;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// propagating constraints</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k&lt;<span class="number">9</span>; k++) &#123;</span><br><span class="line">            <span class="comment">// to the row: </span></span><br><span class="line">            <span class="keyword">if</span> (i != k &amp;&amp; !updateConstraints(k, j, v))</span><br><span class="line">                return <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// to the column:</span></span><br><span class="line">            <span class="keyword">if</span> (j != k &amp;&amp; !updateConstraints(i, k, v))</span><br><span class="line">                return <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// to the 3x3 square:</span></span><br><span class="line">            <span class="keyword">int</span> ix = (i / <span class="number">3</span>) * <span class="number">3</span> + k / <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">int</span> jx = (j / <span class="number">3</span>) * <span class="number">3</span> + k % <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">if</span> (ix != i &amp;&amp; jx != j &amp;&amp; !updateConstraints(ix, jx, v))</span><br><span class="line">                return <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        return <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// update constraints of the cell i,j by excluding possibility of 'excludedValue'</span></span><br><span class="line">    <span class="comment">// once there's one possibility left the function recurses back into set()</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">updateConstraints</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> excludedValue)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        cell&amp; c = cells[i][j];</span><br><span class="line">        <span class="keyword">if</span> (c.constraints[excludedValue]) &#123;</span><br><span class="line">            return <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c.value == excludedValue) &#123;</span><br><span class="line">            return <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        c.constraints.<span class="built_in">set</span>(excludedValue);</span><br><span class="line">        <span class="keyword">if</span> (--c.numPossibilities &gt; <span class="number">1</span>)</span><br><span class="line">            return <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">1</span>; v &lt;= <span class="number">9</span>; v++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!c.constraints[v]) &#123;</span><br><span class="line">                return <span class="built_in">set</span>(i, j, v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        assert(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// backtracking state - list of empty cells</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; bt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find values for empty cells</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">findValuesForEmptyCells</span><span class="params">()</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="comment">// collecting all empty cells</span></span><br><span class="line">        bt.clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!cells[i][j].value)</span><br><span class="line">                    bt.push_back(make_pair(i, j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// making backtracking efficient by pre-sorting empty cells by numPossibilities</span></span><br><span class="line">        sort(bt.begin(), bt.end(), [<span class="keyword">this</span>](const pair&lt;int, int&gt;&amp;a, const pair&lt;int, int&gt;&amp;b) &#123;</span><br><span class="line">            return cells[a.first][a.second].numPossibilities &lt; cells[b.first][b.second].numPossibilities; &#125;);</span><br><span class="line">        return backtrack(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Finds value for all empty cells with index &gt;=k</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> k)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &gt;= bt.size())</span><br><span class="line">            return <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> i = bt[k].first;</span><br><span class="line">        <span class="keyword">int</span> j = bt[k].second;</span><br><span class="line">        <span class="comment">// fast path - only 1 possibility</span></span><br><span class="line">        <span class="keyword">if</span> (cells[i][j].value)</span><br><span class="line">            return backtrack(k + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">auto</span> constraints = cells[i][j].constraints;</span><br><span class="line">        <span class="comment">// slow path &gt;1 possibility.</span></span><br><span class="line">        <span class="comment">// making snapshot of the state</span></span><br><span class="line">        <span class="built_in">array</span>&lt;<span class="built_in">array</span>&lt;cell,9&gt;,9&gt; snapshot(cells);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">1</span>; v &lt;= <span class="number">9</span>; v++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!constraints[v]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">set</span>(i, j, v)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (backtrack(k + <span class="number">1</span>))</span><br><span class="line">                        return <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// restoring from snapshot,</span></span><br><span class="line">                <span class="comment">// note: computationally this is cheaper</span></span><br><span class="line">                <span class="comment">// than alternative implementation with undoing the changes</span></span><br><span class="line">                cells = snapshot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;board)</span> </span>&#123;</span><br><span class="line">        cells = <span class="built_in">array</span>&lt;<span class="built_in">array</span>&lt;cell,<span class="number">9</span>&gt;,<span class="number">9</span>&gt;(); <span class="comment">// clear array</span></span><br><span class="line">        <span class="comment">// Decoding input board into the internal cell matrix.</span></span><br><span class="line">        <span class="comment">// As we do it - constraints are propagated and even additional values are set as we go</span></span><br><span class="line">        <span class="comment">// (in the case if it is possible to unambiguously deduce them).</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] != <span class="string">'.'</span> &amp;&amp; !<span class="built_in">set</span>(i, j, board[i][j] - <span class="string">'0'</span>))</span><br><span class="line">                    return; <span class="comment">// sudoku is either incorrect or unsolvable</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// if we're lucky we've already got a solution,</span></span><br><span class="line">        <span class="comment">// however, if we have empty cells we need to use backtracking to fill them</span></span><br><span class="line">        <span class="keyword">if</span> (!findValuesForEmptyCells())</span><br><span class="line">            return; <span class="comment">// sudoku is unsolvable</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// copying the solution back to the board</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cells[i][j].value)</span><br><span class="line">                    board[i][j] = cells[i][j].value + <span class="string">'0'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<p>####Yet another 0ms C++ solution</p>
<p>It is much faster than pure DFS/Backtracking, since it primarily relies on reactive constraint propagation and uses backtracking only as a fallback. This aspect of the algorithm remains unchanged. See the link above for more detailed description.</p>
<p>The new version posted here, uses the same algorithm, but optimized with the help of moderately-crazy bithacks and modulo-n arithmetic tricks to speedup some things.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">// Table which allows compute the value of the cell</span></span><br><span class="line">    <span class="comment">// from the unambiguous bit mask as maskToValue[(mask%11)-1] </span></span><br><span class="line">    <span class="comment">// uses the fact that (1&lt;&lt;i)%11 is unique for i = [0..8] and never produces 0</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> maskToValue[<span class="number">10</span>] = &#123;<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'9'</span>,<span class="string">'3'</span>,<span class="string">'5'</span>,<span class="string">'6'</span>,<span class="string">'8'</span>,<span class="string">'4'</span>,<span class="string">'7'</span>,<span class="string">'6'</span>&#125;;</span><br><span class="line">    <span class="keyword">struct</span> SudokuSolver &#123;</span><br><span class="line">        <span class="comment">// Using mask for each cell which constraints values which can be in the cell</span></span><br><span class="line">        <span class="comment">// Yeap, it is more storage, comparing to rows/cols/sqrs approach</span></span><br><span class="line">        <span class="comment">// but it allows to do super-fast reactive constraint propagation</span></span><br><span class="line">        <span class="built_in">array</span>&lt;<span class="built_in">array</span>&lt;<span class="keyword">uint16_t</span>,9&gt;,9&gt; board;</span><br><span class="line">        SudokuSolver()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Initializing the board with mask, which permits all numbers</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">9</span>; i++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">9</span>; j++)</span><br><span class="line">                    board[i][j] = <span class="number">0x1ff</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// adds value v [1..9] to the board, return false if it violates constraints</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> v)</span></span><br><span class="line">        </span>&#123;</span><br><span class="line">            return <span class="built_in">set</span>(i, j, <span class="number">1</span>&lt;&lt;(v<span class="number">-1</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// set a value mask to the cell (i,j) and reactively updates constraints</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, uint16_t mask)</span></span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">int16_t</span> prev = board[i][j];</span><br><span class="line">            <span class="keyword">if</span> (prev == mask) return <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (!(prev&amp;mask)) return <span class="literal">false</span>;</span><br><span class="line">            board[i][j] = mask;</span><br><span class="line">            return propagate(i,j,mask);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// propagates constraints as a result of setting i,j to mask</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">propagate</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, uint16_t mask)</span></span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;<span class="number">9</span>; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (k!=j &amp;&amp; !addConstraint(i, k, mask)) return <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (k!=i &amp;&amp; !addConstraint(k, j, mask)) return <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">int</span> ii = (i/<span class="number">3</span>)*<span class="number">3</span> + (k/<span class="number">3</span>);</span><br><span class="line">                <span class="keyword">int</span> jj = (j/<span class="number">3</span>)*<span class="number">3</span> + (k%<span class="number">3</span>);</span><br><span class="line">                <span class="keyword">if</span> ((i != ii || j != jj) &amp;&amp; !addConstraint(ii, jj, mask)) return <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            return <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// prohibits putting value in mask to the cell (i,j)</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">addConstraint</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, uint16_t mask)</span></span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">int16_t</span> newMask = board[i][j] &amp;~ mask;</span><br><span class="line">            <span class="keyword">if</span> (newMask != board[i][j]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (newMask == <span class="number">0</span>) return <span class="literal">false</span>;</span><br><span class="line">                board[i][j] = newMask;</span><br><span class="line">                <span class="keyword">if</span> (((newMask<span class="number">-1</span>)&amp;newMask)==<span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// good news - we have only one possibility for the cell (i,j)</span></span><br><span class="line">                    return propagate(i, j, newMask);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// list of cell coordinates with &gt;1 possibilities for values</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; v;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="comment">// finding all ambiguous cells</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">9</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">9</span>; j++) &#123;</span><br><span class="line">                    <span class="keyword">uint16_t</span> mask = board[i][j];</span><br><span class="line">                    <span class="keyword">if</span> (mask&amp;(mask<span class="number">-1</span>)) v.push_back(make_pair(i,j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// note: it is also a good idea to sort v by the hamming weight, but</span></span><br><span class="line">            <span class="comment">// without sorting it is still super-fast</span></span><br><span class="line">            <span class="comment">// running backtracking as is</span></span><br><span class="line">            backtrack(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// backtracking        </span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (k == v.size()) return <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">int</span> i = v[k].first;</span><br><span class="line">            <span class="keyword">int</span> j = v[k].second;</span><br><span class="line">            <span class="keyword">uint16_t</span> mask = board[i][j];</span><br><span class="line">            <span class="keyword">if</span> (mask&amp;(mask<span class="number">-1</span>)) &#123;</span><br><span class="line">                <span class="comment">// the board state is so compact and backtracking depth is so shallow, so</span></span><br><span class="line">                <span class="comment">// it is cheaper to make a snapshot of the state vs. doing classical</span></span><br><span class="line">                <span class="comment">// undo at each move</span></span><br><span class="line">                <span class="keyword">auto</span> snapshot = board;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">uint16_t</span> cand = <span class="number">1</span>; cand&lt;=<span class="number">0x1ff</span>; cand = cand &lt;&lt;<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">set</span>(i, j, cand) &amp;&amp; backtrack(k+<span class="number">1</span>)) return <span class="literal">true</span>;</span><br><span class="line">                    board = snapshot;</span><br><span class="line">                &#125;</span><br><span class="line">                return <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                return backtrack(k + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        SudokuSolver solver;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">9</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">9</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">char</span> c = board[i][j];</span><br><span class="line">                <span class="keyword">if</span> (c != <span class="string">'.'</span> &amp;&amp; !solver.add(i,j,c-<span class="string">'0'</span>)) return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// At this point 9 of 10 sudokus published in magazines will be solved by constraint propagation</span></span><br><span class="line">        <span class="comment">// only 'hard' sudokus will require some (limited) backtracking </span></span><br><span class="line">        solver.solve();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">9</span>; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">9</span>; j++)</span><br><span class="line">                board[i][j] = maskToValue[(solver.board[i][j]%<span class="number">11</span>)<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<p>##LeetCode-38 Count and Say</p>
<p>#####<font color="red">String </font></p>
<p>The count-and-say sequence is the sequence of integers beginning as follows:<br>1, 11, 21, 1211, 111221, …</p>
<blockquote>
<p>1 is read off as “one 1” or 11.<br>11 is read off as “two 1s” or 21.<br>21 is read off as “one 2, then one 1” or 1211.</p>
<p>Given an integer n, generate the nth sequence.</p>
</blockquote>
<p>Note: The sequence of integers will be represented as a string.</p>
<p>####<strong>my Solution :</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="built_in">string</span> <span class="title">countAndSay</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">string</span> result = <span class="string">"1"</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) </span><br><span class="line">			result = generateNext(result);</span><br><span class="line">		return result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="built_in">string</span> <span class="title">generateNext</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> len = s.length();</span><br><span class="line">		<span class="built_in">string</span> ret = <span class="string">""</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">while</span> (i + <span class="number">1</span> &lt; len &amp;&amp; s[i] == s[i + <span class="number">1</span>]) &#123;</span><br><span class="line">					count++; i++;</span><br><span class="line">			&#125;</span><br><span class="line">			ret = ret + to_string(count) + s[i];</span><br><span class="line">		&#125;</span><br><span class="line">		return ret;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<p>##LeetCode-39 Combination Sum</p>
<p>#####<font color="red">Array Backtracking </font></p>
<p>Given a set of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.</p>
<p>The same repeated number may be chosen from C unlimited number of times.</p>
<p><strong>Note:</strong><br>All numbers (including target) will be positive integers.<br>Elements in a combination (a1, a2, … , ak) must be in non-descending order. (ie, a1 ≤ a2 ≤ … ≤ ak).<br>The solution set must not contain duplicate combinations.<br>For example, given candidate set 2,3,6,7 and target 7,<br>A solution set is: </p>
<blockquote>
<p>[7]<br>[2, 2, 3] </p>
</blockquote>
<p>####<strong>my Solution :</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combinationSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">		<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">		<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">		<span class="keyword">int</span> n = candidates.size();</span><br><span class="line">		<span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">			return ret;</span><br><span class="line">		sort(candidates.begin(), candidates.end());</span><br><span class="line">		dfs(candidates, target, <span class="number">0</span>, temp, ret);</span><br><span class="line">		return ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> start, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;ret)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> n = candidates.size(), i = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (target &lt; candidates[start])</span><br><span class="line">			return;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (i = start; i &lt; n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			temp.push_back(candidates[i]);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (target == candidates[i])</span><br><span class="line">			&#123;</span><br><span class="line">				ret.push_back(temp);</span><br><span class="line">				return;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (target &gt; candidates[i])</span><br><span class="line">			&#123;</span><br><span class="line">				dfs(candidates, target - candidates[i], i, temp, ret);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				return;</span><br><span class="line"></span><br><span class="line">			temp.pop_back();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>##LeetCode-40 Combination Sum II</p>
<p>#####<font color="red">Array Backtracking </font></p>
<p>Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.</p>
<p>Each number in C may only be used once in the combination.</p>
<p><strong>Note:</strong><br>All numbers (including target) will be positive integers.<br>Elements in a combination (a1, a2, … , ak) must be in non-descending order. (ie, a1 ≤ a2 ≤ … ≤ ak).<br>The solution set must not contain duplicate combinations.<br>For example, given candidate set 10,1,2,7,6,1,5 and target 8,<br><strong>A solution set is:</strong> </p>
<blockquote>
<p>[1, 7]<br>[1, 2, 5]<br>[2, 6]<br>[1, 1, 6] </p>
</blockquote>
<p>####<strong>my Solution :</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combinationSum2(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">		<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">		<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">		<span class="keyword">int</span> n = candidates.size();</span><br><span class="line">		<span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">			return ret;</span><br><span class="line">		sort(candidates.begin(), candidates.end());</span><br><span class="line">		dfs(candidates, target, <span class="number">0</span>, temp, ret);</span><br><span class="line">		sort(ret.begin(), ret.end());</span><br><span class="line">		<span class="keyword">auto</span> end_unique = unique(ret.begin(), ret.end());</span><br><span class="line">		ret.erase(end_unique, ret.end());</span><br><span class="line">		return ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> start, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;ret)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> n = candidates.size(), i = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (target &lt; candidates[start])</span><br><span class="line">			return;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (i = start; i &lt; n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			temp.push_back(candidates[i]);</span><br><span class="line">			<span class="keyword">if</span> (target == candidates[i])</span><br><span class="line">			&#123;</span><br><span class="line">				ret.push_back(temp);</span><br><span class="line">				return;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (target &gt; candidates[i])</span><br><span class="line">			&#123;</span><br><span class="line">				dfs(candidates, target - candidates[i], i + <span class="number">1</span>, temp, ret);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				return;</span><br><span class="line"></span><br><span class="line">			temp.pop_back();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>At the beginning, I stuck on this problem. After careful thought, I think this kind of backtracking contains a iterative component and a resursive component so I’d like to give more details to help beginners save time. The revursive component tries the elements after the current one and also tries duplicate elements. So we can get correct answer for cases like [1 1] 2. The iterative component checks duplicate combinations and skip it if it is. So we can get correct answer for cases like [1 1 1] 2.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; combinationSum2(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;num, <span class="keyword">int</span> target) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        sort(num.begin(),num.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; local;</span><br><span class="line">        findCombination(res, <span class="number">0</span>, target, local, num);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">findCombination</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="keyword">int</span> order, <span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; local, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; num)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(local);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(int i = order;i&lt;num.size();i++) <span class="comment">// iterative component</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(num[i]&gt;target) return;</span><br><span class="line">                <span class="keyword">if</span>(i&amp;&amp;num[i]==num[i<span class="number">-1</span>]&amp;&amp;i&gt;order) <span class="keyword">continue</span>; <span class="comment">// check duplicate combination</span></span><br><span class="line">                local.push_back(num[i]),</span><br><span class="line">                findCombination(res,i+<span class="number">1</span>,target-num[i],local,num); <span class="comment">// recursive componenet</span></span><br><span class="line">                local.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>

            <div class="clearfix"></div>
            <hr class="nogutter">
        </div>
        <nav class="pagination" role="pagination">
    
    <a class="pull-left" href="/2016/04/09/数据结构——树（一）/" style="float: left;">
        ← 数据结构——树（一）
    </a>
    
    
    <a class="pull-right" href="/2016/04/08/Leetcode（21-30）/">
        Leetcode（21-30） →
    </a>
    
</nav>

        <div class="duoshuo">
<div class="ds-thread" data-thread-key="2016/04/08/Leetcode（31-40）/" data-title="Leetcode（31-40）" data-url="https://github.com/CornFish98/CornFish98.github.io.git/2016/04/08/Leetcode（31-40）/"></div>
<script type="text/javascript">
var duoshuoQuery = {short_name:"duoshuo_name"};
(function() {
	var ds = document.createElement('script');
	ds.type = 'text/javascript';ds.async = true;
	ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
	ds.charset = 'UTF-8';
	(document.getElementsByTagName('head')[0] 
	 || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script>
</div>
    </div>
</section>


      
<!-- ============================ Footer =========================== -->

<footer>
    <div class="container">
            <div class="copy">
                <p>
                    &copy; 2014<script>new Date().getFullYear()>2010&&document.write("-"+new Date().getFullYear());</script>, Content By ZKY. All Rights Reserved.
                </p>
            </div>
            <div class="social">
                <ul>
                    
                    <li><a href="https://github.com/" title="Github" target="_blank"><i class="icon-github"></i></a>&nbsp;</li>
                    
                    
                    
                    
                    <li><a href="https://google.com/" title="Google-Plus" target="_blank"><i class="icon-google-plus"></i></a>&nbsp;</li>
                    
                    
                    <li><a href="http://weibo.com/" title="Sina-Weibo" target="_blank"><i class="icon-sina-weibo"></i></a>&nbsp;</li>
                    
                </ul>
            </div>
            <div class="clearfix"> </div>
        </div>
</footer>

<!-- ============================ END Footer =========================== -->
      <!-- Load our scripts -->
        
<!-- Resizable 'on-demand' full-height hero -->
<script type="text/javascript">
    
    var resizeHero = function () {
        var hero = $(".cover,.heightblock"),
            window1 = $(window);
        hero.css({
            "height": window1.height()
        });
    };
    
    resizeHero();
    
    $(window).resize(function () {
        resizeHero();
    });
</script>
<script src="/js/plugins.min.js"></script><!-- Bootstrap core and concatenated plugins always load here -->
<script src="/js/jquery.flexslider-min.js"></script><!-- Flexslider plugin -->
<script src="/js/scripts.js"></script><!-- Theme scripts -->

<!-- Initiate flexslider plugin -->
<script type="text/javascript">
    $(document).ready(function($) {
      $('.flexslider').flexslider({
        animation: "fade",
        prevText: "",
        nextText: "",
        directionNav: true
      });
    });
</script>

</body>
</html>
